"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path_to_regexp_1 = require("path-to-regexp");
var Priority;
(function (Priority) {
    Priority[Priority["LAST"] = 0] = "LAST";
    Priority[Priority["LATER"] = 1] = "LATER";
    Priority[Priority["MIDDLE"] = 2] = "MIDDLE";
    Priority[Priority["EARLY"] = 3] = "EARLY";
    Priority[Priority["FIRST"] = 4] = "FIRST";
})(Priority = exports.Priority || (exports.Priority = {}));
class FABRouter {
    constructor() {
        this.pipeline = {
            [Priority.LAST]: [],
            [Priority.LATER]: [],
            [Priority.MIDDLE]: [],
            [Priority.EARLY]: [],
            [Priority.FIRST]: [],
        };
    }
    getPipeline() {
        return [
            ...this.pipeline[Priority.FIRST],
            ...this.pipeline[Priority.EARLY],
            ...this.pipeline[Priority.MIDDLE],
            ...this.pipeline[Priority.LATER],
            ...this.pipeline[Priority.LAST],
        ];
    }
    addToPipeline(responder, priority = Priority.MIDDLE) {
        this.pipeline[priority].push(responder);
    }
    on(route, responder, priority) {
        if (route === '*') {
            // Make this an alias for .onAll, with an empty params object
            this.onAll((context) => responder({ ...context, params: {} }), priority);
        }
        else {
            // Otherwise compile the route and generate a responder
            const groups = [];
            const regexp = path_to_regexp_1.pathToRegexp(route, groups);
            this.addToPipeline(async (context) => {
                const { pathname } = context.url;
                // Only execute if this request matches our route
                const match = regexp.exec(pathname);
                if (match) {
                    const params = {};
                    groups.forEach((group, i) => {
                        params[group.name] = match[i + 1];
                    });
                    return await responder({ ...context, params });
                }
                return undefined;
            }, priority);
        }
    }
    onAll(responder, priority) {
        this.addToPipeline(responder, priority);
    }
    interceptResponse(interceptor, priority = Priority.EARLY) {
        this.addToPipeline(async (context) => {
            return {
                interceptResponse: interceptor,
            };
        }, priority);
    }
}
exports.FABRouter = FABRouter;
class NoopCache {
    constructor() {
        this.set = async () => { };
        this.setJSON = async () => { };
        this.get = async () => undefined;
        this.getJSON = async () => undefined;
        this.getArrayBuffer = async () => undefined;
        this.getNumber = async () => undefined;
        this.getStream = async () => undefined;
    }
}
class FABRuntime {
    constructor(metadata, file_metadata, context) {
        this.Metadata = metadata;
        this.FileMetadata = file_metadata;
        this.Router = new FABRouter();
        this.Cache = context.cache || new NoopCache();
        this.ServerContext = context;
    }
    static initialize(metadata, plugins, context) {
        const instance = new FABRuntime(metadata.plugin_metadata, metadata.file_metadata, context);
        plugins.forEach(({ plugin, args }) => plugin(instance, args));
        return instance;
    }
    getPipeline() {
        return this.Router.getPipeline();
    }
}
exports.FABRuntime = FABRuntime;
//# sourceMappingURL=runtime.js.map